# Обрабока арифметических выражений и привидение их к польской системе


## Цели и задачи

__Цель данной работы__ - разработать статическую библиотеку на языке С++, реализующую
динамическую структуру данных — стек. Структура стек основана на динамической 
структуре данных - список. Также освоение таких инструментов разработки
программного обеспечения, как система контроля версий Git и фрэймворк для
разработки автоматических тестов Google Test.

Выполнение работы предполагает решение следующих задач:

  1. Необходимо создать репозиторий на сайте (http://github.com), в 
котором будут отображены все действия с проектом с соответствущими комментариями.
  1. В качестве примера работы со стеками, разработать программу, реализующую
обработку арифметического выражения и его перевод в постфиксную форму.
  1. Написать тестирующие программы для каждого метода 
структур данных с помощью Google C++ Testing Framework.
  1. Написать консольные приложения, где будет демонстрироваться работа со 
списками, стеками и обработчиком арифметического выражения.

## Руководство пользователя

###*Запуск приложения и ввод данных*

Программа предназначена для обработки и перевода 
арифметического выражения из инфиксной в постфиксную форму и для дальнейшего 
подсчета выражения с введенными пользователем данными. 
Чтобы запустить приложение, необходимо открыть исполняемый файл sample_postfix.exe 
и следовать инструкциям.

Пример:
  1. Введите арифметическое выражение:
![start1](/img/start1.png)

  2. Получим выражение в постфиксной форме:
![start2](/img/start2.png)

  3. Введите постфиксное выражение для подсчета, получим результат:
![start3](/img/start3.png)

  4. Для завершения нажмите любую клавишу.

## Руководство программиста

###*Общая структура проекта*

  - `gtest` — библиотека Google Test.
  - `include` — директория для размещения заголовочных файлов.
  - `samples` — директория для размещения демо-приложений.
  - `sln` — директория с файлами решений и проектов для VS 2012,
    вложенная директория `vc12`.
  - `src` — директория с исходными кодами (cpp-файлы).
  - `test` — директория с модульными тестами и основным приложением,
    инициализирующим запуск тестов.
  - `img` — директория с изображениями, используемых в отчете к лабораторной работе.
  - `README.md` — отчет о лабораторной работе.
  - Служебные файлы
    - `.gitignore` — перечень расширений файлов, игнорируемых Git при добавлении
      файлов в репозиторий.

###*Описание структуры программы*

В решении содержатся следующие модули:

  - `gtest` - фреймворк Google Test.
  - `postfix_lib` - статическая библиотека, которая содержит объявление и реализацию 
шаблонных классов node, list, stack, postfix.
	- `node` - узел списка, хранит значение ключа и указатель на следующий узел.
Класс содержит в себе конструктор по умолчанию, конструктор копирования, деструктор.
	- `list` - список, состоящий из узлов. Имеет конструктор по умолчанию,
конструктор копирования, деструктор, 10 методов по работе со списками.
	- `stack` - стек, реализованнный на основе линейного односвязного списка.
Класс включает в себя конструкторы: по умолчанию, копирования; деструктор, 8 методов 
по работе со стеком.
	- `postfix` - класс обработки, перевода арифметических выражений в постфиксную
форму и подсчет постфиксных выражений. Использует класс *`stack`*. Включает 6 методов.
  - `sample_list` - консольное приложение, пример работы со списком.
  - `sample_stack` - консольное приложение, пример работы со стеком.
  - `sample_postfix` - консольное приложение, пример работы с переводом арифметических выражений
в постфиксную форму и подсчет постфиксного выражения.
  - `postfix_test` - консольное приложение, тестирующее классы list, stack, postfix.
	- `test_main` - запускает тесты.
	- `test_stack` - тестирует стек.
	- `test_postfix` - тестирует класс postfix.

###*Описание структур данных*

####Структура данных "список"
Односвязный линейный список — динамическая структура данных, имеющая неограниченное 
количество элементов. Состоит из узлов, каждый из которых содержит данные определенного 
типа (ключ) и указатель на следующий элемент списка. Узнать адрес предыдущего элемента, 
опираясь на содержимое текущего узла, невозможно. В односвязном списке можно передвигаться 
только в сторону конца списка. Последний элемент списка указывает на NULL. 
Элемент, на который нет указателя, является первым (головным) элементом списка (First). 
Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов 
связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера.

Динамическая структура данных "список" представлена в лабораторной работе в виде шаблонного 
класса list, который содержит в себе следующие методы:
  - Конструктор по умолчанию;
  - Конструктор копирования;
  - Деструктор;
  - `Print` — печать элементов списка;
  - `Find` — поиск элемента с заданным ключом, возвращающий указатель на элемент;
  - `PushStart` — создание и вставка элемента с заданным ключом в начало списка;
  - `PushEnd` — создание и вставка элемента с заданным ключом в конец списка;
  - `PushtBefore` — создание и вставка элемента с заданным ключом перед элементом с заданным ключом;
  - `PushAfter` — создание и вставка элемента с заданным ключом после элемента с заданным ключом;
  - `Remove` — удаление элемента с заданным ключом;
  - `GetFirst` — метод, возвращающий указатель на первый элемент списка;
  - `operator==` - перегруженный метод сравнения списков на равенство;
  - `operator!=` - перегруженный метода сравнения списков на неравенство.

Данные методы протестированы в проекте `postfix_test` в файле `test_list.cpp` и продемонстрированы 
в приложении `sample_list.exe`.

####Структура данных "стек"

Стек - динамическая структура данных, представляющий собой список элементов, организованных по принципу 
LIFO (англ. last in — first out, «последним пришёл — первым вышел»).

Динамическая структура данных "стек" представлена в лабораторной работе в виде шаблонного 
класса *`stack`*, основанного на односвязном списке и содержащего следующие методы:

  - Конструктор по умолчанию;
  - Конструктор копирования;
  - Деструктор;
  - `IsEmpty` — проверка стека на пустоту;
  - `IsFull` — проверка стека на полноту (наличие памяти для создания элемента);
  - `Push` — добавление элемента с заданным ключом на вершину стека;
  - `Pop` — извлечь элемент с вершины стека, возвращающает значение элемента;
  - `Print` — печать элементов стека;
  - `operator==` - перегруженный метод стравнения стеков на равенство;
  - `operator!=` - перегруженный метод сравнения списков на неравенство;
Данные методы протестированы в проекте `postfix_tests` в файле `test_stack.cpp` и продемонстрированы 
в приложении `sample_stack.exe`.

###*Описание алгоритмов*

####Алгоритм перевода в постфиксную запись

Описание алгоритма перевода из инфиксной записи в постфиксную:
 
 1. Арифметическое выражение, введенное пользователем, проверяется на количество скобок.
 
 2. Каждой операции ставится приоритет:
 	- Умножению `*` и делению `/` ставится приоритет 3.
 	- Сложению `+` и вычитанию `-` ставится приоритет 2.
 	- Скобкам `(` и `)` ставится приоритет 1.
	- Равно `=` ставится приоритет 0.
 
 3. Создается 3 стека: стек для хранения операций `operators`, стек для хранения аргументов `arguments`,
стек для хранения результата подсчета выражения постфиксной формы `S`.
 
 4. Возможны 2 случая:
	- Встретился операнд, который добавляется в стек `arguments`;
	- Встретилась новая операция, если:
		1. Приоритет новой операции выше, приоритета операции, лежащей на вершине стека 
`operators`, то добавляем в стек `operators`.
		2. Приоритет новой операции ниже или равен приоритету операции, лежащей на вершине стека 
`operators`, то пока приоритет операции на вершине стека `operators` больше или равно приоритета новой опериции, операции 
из стека перекладывается в `arguments`, а новая операция добавляется в стек `operators`. Если стек `operators` 
пуст, то новая операция просто добавляется в стек `operators`.
		3. Встретились скобки:
			- Встретилась закрывающаяся скобка ")", тогда из стека `operators` все элементы перемещаются в стек `arguments` 
до скобки "(", которая выталкивается из стека `operators`.
			- Встретилась открывающаяся скобка "(", которая просто добавляется в стек `operators`;

 5. Все из  `arguments` перемещаются в стек `operetors`, затем записываются в результирующую строку.

####Алгоритм подсчета выражения в постфиксной записи

Описание алгоритма вычисления арифметического выражения в постфиксной форме:

 1. Создается стек с заданным типом данных RT `S`.
 2. Возможны 2 случая:

	1. Встретился операнд, который добавляется на вершину стека `S`.
	2. Встретилась операция, тогда из стека `S` выталкиваются 2 операнда, над ними совершается указанная операция, 
результат помещается в стек `S`.

 3. По завершению подсчета, в стеке останется результат, который выведется на экран.

##Заключение

В ходе лабораторной работы была разработана программа, реализующая обработку и перевод арифметического 
выражение в обратную польскую форму. С помощью шаблонных классов были реализованы динамические структуры "узел", "список", "стек".
Для каждого класса были написаны тесты, проверяющие их работоспособность.
 
Приложение для списка и стека показывает работу с методами, не запрашивая данных у польхователя. 
Приложение для преобразования выражения в постфиксную форму, запрашивает арифметическое выражение, калькулятор высчитывает значение и выводит на экран результат.

Так же была использована система управления версиями Git: была создана ветка, в которой выполнялась реализация лабораторной работы. 
По мере добавления методов, тестов и приложений файлы добавлялись в репозиторий с соответствующими комментариями.

##Литература

 - Уильям Топп, Уильям Форд "Структуры даннных в C++" -M.: ЗАО "Издательство БИНОМ", 1999. - 816 с.: ил.